package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.symboltable.concepts.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
	
	Boolean syntaxErrorFound = false;   
   
    // redefined error methods
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        //report_error("Syntax Error", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal Error, parsing interrupted", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info != null) {
    		log.info (info.getClass());
    		log.info (info);
		}
    	if (info instanceof Symbol)
            msg.append (" on line ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}

scan with {:
	
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString() + " " + s.left + " " + s.right + " " + s.sym);
	return s;
	
:}

terminal PROGRAM, BREAK, CLASS, ABSTRACT, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXTENDS, CONTINUE, FOREACH, PRIVATE, PROTECTED, PUBLIC;
terminal String IDENT;
terminal Integer NUMBER;
terminal Character CHAR;
terminal Boolean BOOL;
terminal PLUS, MINUS, MUL, DIV, MOD;
terminal PLUSASSIGN, MINUSASSIGN, MULASSIGN, DIVASSIGN, MODASSIGN;
terminal EQUALS, NOT_EQUALS, GREATER_THAN, GREATER_THAN_EQUALS, LESS_THAN, LESS_THAN_EQUALS;
terminal AND, OR, ASSIGN, INC, DEC;
terminal SEMICOLON, COMMA, PERIOD, COLON;
terminal LEFT_BRACE, RIGHT_BRACE, LEFT_BRACKET, RIGHT_BRACKET, LEFT_PARENTHESIS, RIGHT_PARENTHESIS;

non terminal Program; /* from assignment */ 
non terminal rs.ac.bg.etf.pp1.MyObjImpl ProgramName; 
non terminal GlobalDeclarationsList; 
non terminal GlobalMethodDeclarationsList; 
non terminal GlobalDeclaration; 
non terminal ConstDecl; /* from assignment */ 
non terminal VarDecl; /* from assignment */ 
non terminal ClassDecl; /* from assignment */ 
non terminal AbstractClassDecl; /* from assignment */ 
non terminal MethodDecl; /* from assignment */ 
non terminal rs.ac.bg.etf.pp1.MyStructImpl ConstType;
non terminal MultipleConstDecl; 
non terminal SingleConstDecl; 
non terminal ConstName; 
non terminal rs.ac.bg.etf.pp1.MyObjImpl ConstValue;
non terminal rs.ac.bg.etf.pp1.MyStructImpl VarType;
non terminal MultipleVarDecl; 
non terminal SingleVarDecl; 
non terminal VarName; 
non terminal ArrayOption; 
non terminal ClassDeclSyntaxCheck; 
non terminal AbstractClassDeclSyntaxCheck; 
non terminal rs.ac.bg.etf.pp1.MyObjImpl ClassName; 
non terminal ExtendsOption; 
non terminal ExtendsSyntaxCheck; 
non terminal rs.ac.bg.etf.pp1.MyStructImpl SuperClassName; 
non terminal ClassFieldsList; 
non terminal ClassField; 
non terminal AccessModifier;
non terminal rs.ac.bg.etf.pp1.MyStructImpl FieldType;
non terminal MultpleClassFieldDecl; 
non terminal SingleClassFieldDecl; 
non terminal FieldName; 
non terminal ClassMethodsOption; 
non terminal AbstractClassMethodsOption; 
non terminal ClassMethodsList; 
non terminal AbstractClassMethodsList; 
non terminal ClassMethodDecl; 
non terminal AbstractMethodDecl; /* from assignment */ 
non terminal AbstractMethodDeclSyntaxCheck; 
non terminal rs.ac.bg.etf.pp1.MyStructImpl ReturnType; 
non terminal rs.ac.bg.etf.pp1.MyObjImpl AbstractMethodName; 
non terminal rs.ac.bg.etf.pp1.MyObjImpl ClassMethodName; 
non terminal rs.ac.bg.etf.pp1.MyObjImpl MethodName; 
non terminal FormParsOption; 
non terminal LocalVarDeclList; 
non terminal LocalVarDecl; 
non terminal LocalVarDeclSyntaxCheck;
non terminal rs.ac.bg.etf.pp1.MyStructImpl LocalVarDeclType;
non terminal MultipleLocalVarDecl; 
non terminal SingleLocalVarDecl; 
non terminal SingleVarDeclSyntaxCheck; 
non terminal LocalVarName; 
non terminal StatementList;
non terminal FormPars; /* from assignment */ 
non terminal SingleFormPar; 
non terminal SingleFormParSyntaxCheck;
non terminal rs.ac.bg.etf.pp1.MyStructImpl FormParType;
non terminal FormParName; 
non terminal rs.ac.bg.etf.pp1.MyStructImpl Type; /* from assignment */ 
non terminal Statement; /* from assignment */ 
non terminal MatchedStatement; 
non terminal UnmatchedStatement; 
non terminal DesignatorStatement; /* from assignment */ 
non terminal rs.ac.bg.etf.pp1.MyObjImpl Destination; 
non terminal Source; 
non terminal ActParamsOption; 
non terminal ActPars; /* from assignment */ 
non terminal SingleActPar; 
non terminal If; 
non terminal LeftParenthesis; 
non terminal LeftBracket;
non terminal Else; 
non terminal For; 
non terminal FirstDesignatorStatementOption; 
non terminal ConditionOption; 
non terminal ConditionSyntaxCheck; 
non terminal SecondDesignatorStatementOption; 
non terminal Foreach; 
non terminal IteratorName; 
non terminal ForeachArray; 
non terminal Return; 
non terminal ReturnExprOption; 
non terminal PrintOption; 
non terminal rs.ac.bg.etf.pp1.MyStructImpl Condition; /* from assignment */ 
non terminal rs.ac.bg.etf.pp1.MyStructImpl CondTerm; /* from assignment */ 
non terminal rs.ac.bg.etf.pp1.MyStructImpl CondFact; /* from assignment */ 
non terminal rs.ac.bg.etf.pp1.MyStructImpl FirstExpr;
non terminal rs.ac.bg.etf.pp1.MyStructImpl SecondExpr;
non terminal rs.ac.bg.etf.pp1.MyStructImpl Expr; /* from assignment */
non terminal rs.ac.bg.etf.pp1.MyStructImpl NoAssignExpr;
non terminal rs.ac.bg.etf.pp1.MyStructImpl Term; /* from assignment */
non terminal rs.ac.bg.etf.pp1.MyStructImpl Factor; /* from assignment */
non terminal rs.ac.bg.etf.pp1.MyObjImpl Designator; /* from assignment */
non terminal Assignop; /* from assignment */
non terminal Relop; /* from assignment */
non terminal Addop; /* from assignment */
non terminal AddopLeft;
non terminal AddopRight;
non terminal Mulop; /* from assignment */
non terminal MulopLeft;
non terminal MulopRight;

Program ::= (Program) PROGRAM ProgramName GlobalDeclarationsList LEFT_BRACE GlobalMethodDeclarationsList RIGHT_BRACE ;

ProgramName ::= (ProgramName) IDENT:programName ;

GlobalDeclarationsList ::= (GlobalDeclarations) GlobalDeclarationsList GlobalDeclaration
                           |
						   (NoGlobalDeclarations) /* epsilon */ ;
						   
GlobalMethodDeclarationsList ::= (GlobalMethodDeclarations) GlobalMethodDeclarationsList MethodDecl
                                 |
								 (NoGlobalMethodDeclarations) /* epsilon */ ;
								 
GlobalDeclaration ::= (ConstDeclaration) ConstDecl
                      |
					  (VarDeclaration) VarDecl
					  |
					  (ClassDeclaration) ClassDecl
					  |
					  (AbstractClassDeclaration) AbstractClassDecl ;
					  
ConstDecl ::= (ConstDecl) CONST ConstType MultipleConstDecl SEMICOLON ;

ConstType ::= (ConstType) Type;

MultipleConstDecl ::= (MultipleConstDeclaration) MultipleConstDecl COMMA SingleConstDecl
                      |
					  (SingleConstDeclaration) SingleConstDecl ;
					  
SingleConstDecl ::= (SingleConstDecl) ConstName ASSIGN ConstValue ;

ConstName ::= (ConstName) IDENT:constName ;

ConstValue ::= (NumberConst) NUMBER:numberConst
               |
			   (CharConst) CHAR:charConst
			   |
			   (BoolConst) BOOL:boolConst ;
			   
VarDecl ::= (VarDecl) VarType MultipleVarDecl SEMICOLON ;

VarType ::= (VarType) Type;

MultipleVarDecl ::= (MultipleVarDeclaration) MultipleVarDecl COMMA SingleVarDecl
                    |
					(SingleVarDeclaration) SingleVarDecl ;
					
SingleVarDecl ::= (SingleVarDecl) VarName ArrayOption ;

VarName ::= (VarName) IDENT:varName ;

ArrayOption ::= (ArrayVariable) LEFT_BRACKET RIGHT_BRACKET
                |
				(NoArrayVariable) /* epsilon */ ;
				
ClassDecl ::= (ClassDecl) CLASS ClassDeclSyntaxCheck ExtendsOption LEFT_BRACE ClassFieldsList ClassMethodsOption RIGHT_BRACE ;

AbstractClassDecl ::= (AbstractClassDecl) ABSTRACT AbstractClassDeclSyntaxCheck ExtendsOption LEFT_BRACE ClassFieldsList AbstractClassMethodsOption RIGHT_BRACE ;

ClassDeclSyntaxCheck ::= (ClassDeclSuccess) ClassName
                         |
						 (ClassDeclError) error:e
						 {: parser.report_error("Syntax Error on line " + eleft + "; error in class declaration", null); parser.syntaxErrorFound = true; :} ;
						 
AbstractClassDeclSyntaxCheck ::= (AbstractClassDeclSuccess) CLASS ClassName
                                 |
						         (AbstractClassDeclError) error:e
						         {: parser.report_error("Syntax Error on line " + eleft + "; error in abstract class declaration", null); parser.syntaxErrorFound = true; :} ;
						 
ClassName ::= (ClassName) IDENT:className ;
						 
ExtendsOption ::= (ClassInheritance) ExtendsSyntaxCheck
                  |
				  (NoClassInheritance) /* epsilon */ ;
				  
ExtendsSyntaxCheck ::= (ClassInheritanceSuccess) EXTENDS SuperClassName
                       |
					   (ClassInheritanceError) error:e
					   {: parser.report_error("Syntax Error on line " + eleft + "; error in class inheritance", null); parser.syntaxErrorFound = true; :} ;
					   
SuperClassName ::= (SuperClassName) Type:superClassName ;

ClassFieldsList ::= (ClassFields) ClassFieldsList ClassField
                    |
					(NoClassFields) /* epsilon */ ;
					
ClassField ::= (ClassField) AccessModifier FieldType MultpleClassFieldDecl SEMICOLON ;

FieldType ::= (FieldType) Type;

AccessModifier ::= (PublicAccess) PUBLIC
                   |
				   (ProtectedAccess) PROTECTED
				   |
				   (PrivateAccess) PRIVATE ;
				   
MultpleClassFieldDecl ::= (MultipleClassFieldDeclarations) MultpleClassFieldDecl COMMA SingleClassFieldDecl
                          |
						  (SingleClassFieldDeclaration) SingleClassFieldDecl ;
						  
SingleClassFieldDecl ::= (SingleClassFieldDecl) FieldName ArrayOption ;

FieldName ::= (FieldName) IDENT:fieldName ;
					
ClassMethodsOption ::= (ClassMethods) LEFT_BRACE ClassMethodsList RIGHT_BRACE
                       |
					   (NoClassMethods) /* epsilon */ ;
					   
AbstractClassMethodsOption ::= (AbstractClassMethods) LEFT_BRACE AbstractClassMethodsList RIGHT_BRACE
                               |
					           (NoAbstractClassMethods) /* epsilon */ ;
							   
ClassMethodsList ::= (ClassMethodDeclarations) ClassMethodsList ClassMethodDecl
                     |
					 (NoClassMethodDeclarations) /* epsilon */ ;
					 
AbstractClassMethodsList ::= (AbstractClassMethodDeclaration) AbstractClassMethodsList ClassMethodDecl
                             |
							 (AbstractClassAbstractMethodDeclaration) AbstractClassMethodsList AbstractMethodDecl
							 |
							 (NoAbstractClassMethodDeclarations) /* epsilon */ ;
							 
AbstractMethodDecl ::= (AbstractMethodDecl) AbstractMethodDeclSyntaxCheck SEMICOLON ;

AbstractMethodDeclSyntaxCheck ::= (AbstractMethodDeclSuccess) AccessModifier ABSTRACT ReturnType AbstractMethodName LEFT_PARENTHESIS FormParsOption RIGHT_PARENTHESIS
                                  |
								  (AbstractMethodDeclError) error:e
								  {: parser.report_error("Syntax Error on line " + eleft + "; error in abstract method declaration", null); parser.syntaxErrorFound = true; :} ;
								  
ReturnType ::= (VoidReturn) VOID
               |
			   (NoVoidReturn) Type ;
								  
ClassMethodDecl ::= (ClassMethodDecl) AccessModifier ReturnType ClassMethodName LEFT_PARENTHESIS FormParsOption RIGHT_PARENTHESIS LocalVarDeclList LEFT_BRACE StatementList RIGHT_BRACE ;

MethodDecl ::= (MethodDecl) ReturnType MethodName LEFT_PARENTHESIS FormParsOption RIGHT_PARENTHESIS LocalVarDeclList LEFT_BRACE StatementList RIGHT_BRACE ;

AbstractMethodName ::= (AbstractMethodName) IDENT:abstractMethodName ;

ClassMethodName ::= (ClassMethodName) IDENT:classMethodName ;

MethodName ::= (MethodName) IDENT:methodName ;

FormParsOption ::= (FormalParameters) FormPars
                   |
				   (NoFormalParameters) /* epsilon */ ;
				   
FormPars ::= (MultipleFormalParameters) FormPars COMMA SingleFormPar
             |
			 (SingleFormalParameter) SingleFormPar ;
			 
SingleFormPar ::= (SingleFormPar) SingleFormParSyntaxCheck ;
			 
SingleFormParSyntaxCheck ::= (SingleFormParSuccess) FormParType FormParName ArrayOption
                             |
							 (SingleFormParError) error:e
							 {: parser.report_error("Syntax Error on line " + eleft + "; error in formal parameter declaration", null); parser.syntaxErrorFound = true; :} ;
							 
FormParType ::= (FormParType) Type;

FormParName ::= (FormParName) IDENT:formParName ;
				   
LocalVarDeclList ::= (LocalVarDeclarations) LocalVarDeclList LocalVarDecl
                     |
					 (NoLocalVarDeclarations) /* epsilon */ ;
					 
LocalVarDecl ::= (LocalVarDecl) LocalVarDeclSyntaxCheck SEMICOLON ;

LocalVarDeclSyntaxCheck ::= (LocalVarDeclSuccess) LocalVarDeclType MultipleLocalVarDecl
                            |
							(LocalVarDeclError) error:e
							{: parser.report_error("Syntax Error on line " + eleft + "; error in local variable declaration", null); parser.syntaxErrorFound = true; :} ;
							
LocalVarDeclType ::= (LocalVarDeclType) Type ;
							
MultipleLocalVarDecl ::= (MultipleLocalVarDeclaration) MultipleLocalVarDecl COMMA SingleLocalVarDecl
                         |
						 (SingleLocalVarDeclaration) SingleLocalVarDecl ;
						 
SingleLocalVarDecl ::= (SingleLocalVarDecl) SingleVarDeclSyntaxCheck ;

SingleVarDeclSyntaxCheck ::= (SingleLocalVarDeclSuccess) LocalVarName ArrayOption
                             |
							 (SingleLocalVarDeclError) error:e
							 {: parser.report_error("Syntax Error on line " + eleft + "; error in local variable declaration", null); parser.syntaxErrorFound = true; :} ;
							 
LocalVarName ::= (LocalVarName) IDENT:localVarName ;

StatementList ::= (Statements) StatementList Statement
                  |
				  (NoStatements) /* epsilon */ ;
						 
Type ::= (Type) IDENT:typeName ;

Statement ::= (MatchedStmt) MatchedStatement
              |
			  (UnmatchedStmt) UnmatchedStatement ;
			  
MatchedStatement ::= (MatchedDesignatorStatement) DesignatorStatement SEMICOLON
                     |
					 (MatchedIfStatement) If LeftParenthesis Condition RIGHT_PARENTHESIS MatchedStatement Else MatchedStatement
					 |
					 (MatchedForStatement) For LEFT_PARENTHESIS FirstDesignatorStatementOption SEMICOLON ConditionOption SEMICOLON SecondDesignatorStatementOption RIGHT_PARENTHESIS MatchedStatement
					 |
					 (MatchedForeachStatement) Foreach LEFT_PARENTHESIS IteratorName COLON ForeachArray RIGHT_PARENTHESIS MatchedStatement
					 |
					 (BreakStatement) BREAK SEMICOLON
					 |
					 (ContinueStatement) CONTINUE SEMICOLON
					 |
					 (ReturnStatement) Return ReturnExprOption SEMICOLON
					 |
					 (ReadStatement) READ LEFT_PARENTHESIS Designator RIGHT_PARENTHESIS SEMICOLON
					 |
					 (PrintStatement) PRINT LeftParenthesis Expr PrintOption RIGHT_PARENTHESIS SEMICOLON
					 |
					 (StatementsBlock) LEFT_BRACE StatementList RIGHT_BRACE ;
					 
UnmatchedStatement ::= (UnmatchedIfStatement) If LeftParenthesis Condition RIGHT_PARENTHESIS Statement
                       |
					   (UnmatchedElseStatement) If LeftParenthesis Condition RIGHT_PARENTHESIS MatchedStatement Else UnmatchedStatement
					   |
					   (UnmatchedForStatement) For LEFT_PARENTHESIS FirstDesignatorStatementOption SEMICOLON ConditionOption SEMICOLON SecondDesignatorStatementOption RIGHT_PARENTHESIS UnmatchedStatement
					   |
					   (UnmatchedForeachStatement) Foreach LEFT_PARENTHESIS IteratorName COLON ForeachArray RIGHT_PARENTHESIS UnmatchedStatement ;
								   
DesignatorStatement ::= (AssignStatement) Destination Assignop Source
                        |
						(MethodCallStatement) Destination LeftParenthesis ActParamsOption RIGHT_PARENTHESIS 
						|
						(IncrementStatement) Destination INC
						|
						(DecrementStatement) Destination DEC ;
						
Destination ::= (Destination) Designator ;

Source ::= (SourceSuccess) Expr
           |
		   (SourceError) error:e
		   {: parser.report_error("Syntax Error on line " + eleft + "; error in designator (assign) statement", null); parser.syntaxErrorFound = true; :} ;

ActParamsOption ::= (ActualParameters) ActPars
                    |
				    (NoActualParameters) /* epsilon */ ;
				  
ActPars ::= (MultipleActualParameters) ActPars COMMA SingleActPar
            |
			(SinglActualParameter) SingleActPar ;
			
SingleActPar ::= (SingleActPar) Expr ;
						
If ::= (If) IF ;

LeftParenthesis ::= (LeftParenthesis) LEFT_PARENTHESIS ;

LeftBracket ::= (LeftBracket) LEFT_BRACKET ;

Else ::= (Else) ELSE ;

For ::= (For) FOR ;

FirstDesignatorStatementOption ::= (FirstDesignatorStatement) DesignatorStatement
                                   |
								   (NoFirstDesignatorStatement) /* epsilon */ ;

ConditionOption ::= (ForCondition) ConditionSyntaxCheck
                    |
					(NoForCondition) /* epsilon */ ;
					
ConditionSyntaxCheck ::= (ForConditionSuccess) Condition
                         |
						 (ForConditionError) error:e
						 {: parser.report_error("Syntax Error on line " + eleft + "; error in logical condition in for statement", null); parser.syntaxErrorFound = true; :} ;
						 
SecondDesignatorStatementOption ::= (SecondDesignatorStatement) DesignatorStatement
                                    |
								    (NoSecondDesignatorStatement) /* epsilon */ ;
									
Foreach ::= (Foreach) FOREACH ;

IteratorName ::= (IteratorName) IDENT:iteratorName ;

ForeachArray ::= (ForeachArray) Designator ;

Return ::= (Return) RETURN ;

ReturnExprOption ::= (ReturnExpr) Expr
                     |
					 (NoReturnExpr) /* epsilon */ ;
					 
PrintOption ::= (PrintArg) COMMA NUMBER
                |
				(NoPrintArg) /* epsilon */ ;
				
Condition ::= (MultipleTermCondition) Condition OR CondTerm
              |
			  (SingleTermCondition) CondTerm ;
			  
CondTerm ::= (MultipleFactTerm) CondTerm AND CondFact
             |
			 (SingleFactTerm) CondFact ;
			 
CondFact ::= (MultipleExprFact) FirstExpr Relop SecondExpr
             |
             (SingleExprFact) Expr ;
			 
FirstExpr ::= (FirstExpr) Expr ;

SecondExpr ::= (SecondExpr) Expr ;
			 
Expr ::= (ExprWithAssign) Destination Assignop Expr
         |
		 (ExprWithoutAssign) NoAssignExpr ;

NoAssignExpr ::= (MultipleTermExpr) NoAssignExpr AddopLeft Term
		         |
                 (SingleTermExpr) Term
                 |
                 (MinusTermExpr) MINUS Term ;
		 
Term ::= (MultipleFactorTerm) Term MulopLeft Factor
         |
		 (SingleFactorTerm) Factor ;
		 
Factor ::= (FactorDesignator) Designator
           |
		   (MethodDesignator) Designator LeftParenthesis ActParamsOption RIGHT_PARENTHESIS
		   |
		   (ConstFactor) ConstValue 
		   |
		   (NewFactor) NEW Type
           |
           (NewArrayFactor) NEW Type LeftBracket Expr RIGHT_BRACKET
           |
           (CompositeFactor) LeftParenthesis Expr RIGHT_PARENTHESIS ;
		   
Designator ::= (SimpleDesignator) IDENT:designatorName
               |
			   (ArrayDesignator) Designator LeftBracket Expr RIGHT_BRACKET
			   |
			   (ClassDesignator) Designator PERIOD IDENT:fieldName ;
			   
Assignop ::= (Assign) ASSIGN
             |
			 (AddopAssign) AddopRight
			 |
			 (MulopAssign) MulopRight;
			 
Relop ::= (Equals) EQUALS
          |
		  (NotEquals) NOT_EQUALS
		  |
		  (GreaterThan) GREATER_THAN
		  |
		  (GreaterThanEquals) GREATER_THAN_EQUALS
		  |
		  (LessThan) LESS_THAN
		  |
		  (LessThanEquals) LESS_THAN_EQUALS ;
			 
Addop ::= (LeftAddop) AddopLeft
          |
		  (RightAddop) AddopRight;
		  
AddopLeft ::= (Plus) PLUS
              |
			  (Minus) MINUS ;
			  
AddopRight ::= (PlusAssign) PLUSASSIGN
               |
			   (MinusAssign) MINUSASSIGN ;
			   
Mulop ::= (LeftMulop) MulopLeft
          |
		  (RightMulop) MulopRight ;
		  
MulopLeft ::= (Mul) MUL
              |
			  (Div) DIV
			  |
			  (Mod) MOD ;
			  
MulopRight ::= (MulAssign) MULASSIGN
               |
			   (DivAssign) DIVASSIGN
			   |
			   (ModAssign) MODASSIGN ;
		  
