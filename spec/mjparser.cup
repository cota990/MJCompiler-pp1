package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.symboltable.concepts.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
	
	Boolean syntaxErrorFound = false;   
   
    // redefined error methods
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        //report_error("Syntax Error", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal Error, parsing interrupted", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info != null) {
    		log.info (info.getClass());
    		log.info (info);
		}
    	if (info instanceof Symbol)
            msg.append (" on line ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}

scan with {:
	
	Symbol s = this.getScanner().next_token();
	/*if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString()); */
	return s;
	
:}

terminal PROGRAM, BREAK, CLASS, ABSTRACT, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXTENDS, CONTINUE, FOREACH, PRIVATE, PROTECTED, PUBLIC;
terminal String IDENT;
terminal Integer NUMBER;
terminal Character CHAR;
terminal Boolean BOOL;
terminal PLUS, MINUS, MUL, DIV, MOD;
terminal PLUSASSIGN, MINUSASSIGN, MULASSIGN, DIVASSIGN, MODASSIGN;
terminal EQUALS, NOT_EQUALS, GREATER_THAN, GREATER_THAN_EQUALS, LESS_THAN, LESS_THAN_EQUALS;
terminal AND, OR, ASSIGN, INC, DEC;
terminal SEMICOLON, COMMA, PERIOD, COLON;
terminal LEFT_BRACE, RIGHT_BRACE, LEFT_BRACKET, RIGHT_BRACKET, LEFT_PARENTHESIS, RIGHT_PARENTHESIS;

non terminal Program; /* non terminal from assignment */ /* developed */
non terminal ProgramName; /* developed */
non terminal GlobalDeclarationsList; /* developed */
non terminal GlobalMethodDeclarationsList; /* developed */
non terminal GlobalDeclaration; /* developed */
non terminal ConstDecl; /* non terminal from assignment */ /* developed */
non terminal VarDecl; /* non terminal from assignment */ /* developed */
non terminal AbstractClassDecl; /* non terminal from assignment */ /* developed */
non terminal ClassDecl; /* non terminal from assignment */ /* developed */
non terminal ConstDeclSyntaxCheck; /* developed */
non terminal MultipleConstDecl; /* developed */
non terminal SingleConstDecl; /* developed */
non terminal SingleConstDeclSyntaxCheck; /* developed */
non terminal ConstName; /* developed */
non terminal ConstValue; /* developed */
non terminal VarDeclSyntaxCheck; /* developed */
non terminal MultipleVarDecl; /* developed */
non terminal SingleVarDecl; /* developed */
non terminal SingleVarDeclSyntaxCheck; /* developed */
non terminal VarName; /* developed */
non terminal ArrayOption; /* developed */
non terminal ClassDeclSyntaxCheck; /* developed */
non terminal ClassName; /* developed */
non terminal ExtendsOption; /* developed */
non terminal FieldDeclarationsList; /* developed */
non terminal ClassMethodDeclarationsOption; /* developed */
non terminal ExtendsSyntaxCheck; /* developed */
non terminal SuperClass; /* developed */
non terminal SuperClassSyntaxCheck; /* developed */
non terminal SuperClassName; /* developed */
non terminal FieldDeclaration; /* developed */
non terminal FieldDeclSyntaxCheck; /* developed */
non terminal AccessModifier; /* developed */
non terminal MultipleFieldDecl; /* developed */
non terminal SingleFieldDecl; /* developed */
non terminal SingleFieldDeclSyntaxCheck; /* developed */
non terminal FieldName; /* developed */
non terminal ClassMethodDeclarationsList; /* developed */
non terminal AbstractClassDeclSyntaxCheck; /* developed */
non terminal AbstractClassName; /* developed */
non terminal AbstractClassMethodDeclarationsOption; /* developed */
non terminal AbstractClassMethodDeclarationsList; /* developed */
non terminal AbstractMethodDecl; /* non terminal from assignment */ /* developed */
non terminal ClassMethodDecl; /* developed */
non terminal MethodDecl; /* non terminal from assignment */ /* developed */
non terminal ReturnType; /* developed */
non terminal MethodDeclStructure; /* developed */
non terminal MethodDeclSyntaxCheck; /* developed */
non terminal ClassMethodSyntaxCheck; /* developed */
non terminal AbstractMethodDeclSyntaxCheck; /* developed */
non terminal MethodName; /* developed */
non terminal AbstractMethodName; /* developed */
non terminal FormParsOption; /* developed */
non terminal LocalVarDeclarationsList; /* developed */
non terminal StatementList; /* developed */
non terminal FormPars; /* non terminal from assignment */ /* developed */
non terminal LocalVarDecl; /* developed */
non terminal LocalVarDeclSyntaxCheck; /* developed */
non terminal MultipleLocalVarDecl; /* developed */
non terminal SingleLocalVarDecl; /* developed */
non terminal SingleLocalVarDeclSyntaxCheck; /* developed */
non terminal LocalVarName; /* developed */
non terminal SingleFormPar; /* developed */
non terminal FormParName; /* developed */
non terminal Type; /* non terminal from assignment */ /* developed */
non terminal Statement; /* non terminal from assignment */ /* developed */
non terminal MatchedStatement; /* developed */
non terminal UnmatchedStatement; /* developed */
non terminal MatchedDesignatorStatementSyntaxCheck; /* developed */
non terminal DesignatorStatement; /* non terminal from assignment */ /* developed */
non terminal MatchedIfSyntaxCheck; /* developed */
non terminal If; /* developed */
non terminal LeftParenthesisExprStart; /* developed */
non terminal ConditionSyntaxCheck; /* developed */
non terminal Else; /* developed */
non terminal MatchedForSyntaxCheck; /* developed */
non terminal For; /* developed */
non terminal FirstForDesignatorOption; /* developed */
non terminal ForConditionOption; /* developed */
non terminal SecondForDesignatorOption; /* developed */
non terminal MatchedForEachSyntaxCheck; /* developed */
non terminal Foreach; /* developed */
non terminal IteratorName; /* developed */
non terminal ForeachArray; /* developed */
non terminal BreakSyntaxCheck; /* developed */
non terminal ContinueSyntaxCheck; /* developed */
non terminal ReturnSyntaxCheck; /* developed */
non terminal Return; /* developed */
non terminal ReturnExprOption; /* developed */
non terminal ReadSyntaxCheck; /* developed */
non terminal Designator; /* non terminal from assignment */ /* developed */
non terminal PrintSyntaxCheck; /* developed */
non terminal ExprSyntaxCheck; /* developed */
non terminal PrintOption; /* developed */
non terminal UnmatchedIfSyntaxCheck; /* developed */
non terminal UnmatchedElseSyntaxCheck; /* developed */
non terminal IfError; /* developed */
non terminal UnmatchedForSyntaxCheck; /* developed */
non terminal ForError; /* developed */
non terminal UnmatchedForEachSyntaxCheck; /* developed */
non terminal ForEachError; /* developed */
non terminal AssignStatementSyntaxCheck; /* developed */
non terminal MethodCallName; /* developed */
non terminal ActParsOption; /* developed */
non terminal Destination; /* developed */
non terminal Source; /* developed */
non terminal Assignop; /* non terminal from assignment */ /* developed */
non terminal ActPars; /* non terminal from assignment */ /* developed */
non terminal SingleActPar; /* developed */
non terminal Condition; /* non terminal from assignment */ /* developed */
non terminal AddopRight; /* non terminal from assignment */
non terminal MulopRight; /* non terminal from assignment */
non terminal CondTerm; /* non terminal from assignment */ /* developed */
non terminal CondFact; /* non terminal from assignment */ /* developed */
non terminal FirstExpr; /* developed */
non terminal SecondExpr; /* developed */
non terminal SingleExpr; /* developed */
non terminal Relop; /* non terminal from assignment */ /* developed */
non terminal Expr; /* non terminal from assignment */ /* developed */
non terminal AssignExpr; /* developed */
non terminal NoAssignExpr; /* developed */
non terminal AddopLeft; /* non terminal from assignment */
non terminal Term; /* non terminal from assignment */ /* developed */
non terminal MulopLeft; /* non terminal from assignment */
non terminal Factor; /* non terminal from assignment */ /* developed */
non terminal FactorDesignator; /* developed */
non terminal ConstFactor; /* developed */
non terminal LeftBracketExprStart; /* developed */

Program ::= (Program) PROGRAM ProgramName:programName GlobalDeclarationsList:globalDeclarationsList LEFT_BRACE GlobalMethodDeclarationsList:globalMethodDeclarationsList RIGHT_BRACE ;

ProgramName ::= (ProgramName) IDENT:programName ;

GlobalDeclarationsList ::= (GlobalDeclarations) GlobalDeclarationsList GlobalDeclaration
                           |
						   (NoGlobalDeclarations) /* epsilon */ ;
						   
GlobalDeclaration ::= (ConstDeclaration) ConstDecl
                      |
					  (VarDeclaration) VarDecl
					  |
					  (AbstractClassDeclaration) AbstractClassDecl
					  |
					  (ClassDeclaration) ClassDecl ;
					  
ConstDecl ::= (ConstDecl) CONST ConstDeclSyntaxCheck SEMICOLON ;

ConstDeclSyntaxCheck ::= (ConstDeclSuccess) Type MultipleConstDecl
                         |
						 (ConstDeclError) error:e
						 {: parser.report_error("Syntax Error on line " + eleft + "; error in constant declaration", null); parser.syntaxErrorFound = true; :} ;
						 
MultipleConstDecl ::= (MultipleConstDeclaration) MultipleConstDecl COMMA SingleConstDecl
                      |
					  (SingleConstDeclaration) SingleConstDecl ;
					  
SingleConstDecl ::= (SingleConstDecl) SingleConstDeclSyntaxCheck ;

SingleConstDeclSyntaxCheck ::= (SingleConstDeclSuccess) ConstName ASSIGN ConstValue
                               |
							   (SingleConstDeclError) error:e
							   {: parser.report_error("Syntax Error on line " + eleft + "; error in constant declaration", null); parser.syntaxErrorFound = true; :} ;
							   
ConstName ::= (ConstName) IDENT:constName ;

ConstValue ::= (NumConst) NUMBER:numValue 
               |
			   (CharConst) CHAR:charValue
			   |
			   (BoolValue) BOOL:boolValue ;
			   
VarDecl ::= (VarDecl) VarDeclSyntaxCheck SEMICOLON ;

VarDeclSyntaxCheck ::= (GlobalVarDeclSuccess) Type MultipleVarDecl
                       |
					   (GlobalVarDeclError) error:e
					   {: parser.report_error("Syntax Error on line " + eleft + "; error in global variable declaration", null); parser.syntaxErrorFound = true; :} ;
					   
MultipleVarDecl ::= (MultipleGlobalVarDeclaration) MultipleVarDecl COMMA SingleVarDecl
                    |
					(SingleGlobalVarDeclaration) SingleVarDecl ;
					
SingleVarDecl ::= (SingleGlobalVarDecl) SingleVarDeclSyntaxCheck ;

SingleVarDeclSyntaxCheck ::= (SingleGlobalVarDeclSuccess) VarName ArrayOption
                             |
							 (SingleGlobalVarDeclError) error:e
							 {: parser.report_error("Syntax Error on line " + eleft + "; error in global variable declaration", null); parser.syntaxErrorFound = true; :} ;
							 
VarName ::= (VarName) IDENT:varName ;

ArrayOption ::= (ArrayVariable) LEFT_BRACKET RIGHT_BRACKET
                |
				(NoArrayVariable) /* epsilon */
				|
				(ArrayVariableError) error:e
				{: parser.report_error("Syntax Error on line " + eleft + "; error in array declaration", null); parser.syntaxErrorFound = true; :} ;
				
ClassDecl ::= (ClassDecl) CLASS ClassDeclSyntaxCheck RIGHT_BRACE ;

ClassDeclSyntaxCheck ::= (ClassDeclSuccess) ClassName ExtendsOption LEFT_BRACE FieldDeclarationsList ClassMethodDeclarationsOption
                         |
						 (ClassDeclError) error:e
						 {: parser.report_error("Syntax Error on line " + eleft + "; error in class declaration", null); parser.syntaxErrorFound = true; :} ;
						 
ClassName ::= (ClassName) IDENT:className ;

ExtendsOption ::= (ClassInheritance) ExtendsSyntaxCheck
                  |
				  (NoClassInheritance) /* epsilon */ ;
				  
ExtendsSyntaxCheck ::= (ClassInheritenceSuccess) EXTENDS SuperClass
                       |
					   (ClassInheritenceError) error:e
					   {: parser.report_error("Syntax Error on line " + eleft + "; error in class inheritance", null); parser.syntaxErrorFound = true; :} ;
					   
SuperClass ::= (SuperClass) SuperClassSyntaxCheck ;

SuperClassSyntaxCheck ::= (SuperClassSuccess) SuperClassName
                          |
						  (SuperClassError) error:e
					      {: parser.report_error("Syntax Error on line " + eleft + "; error in class inheritance", null); parser.syntaxErrorFound = true; :} ;
						  
SuperClassName ::= (SuperClassName) IDENT:superClassName ;

FieldDeclarationsList ::= (FieldDeclarations) FieldDeclarationsList FieldDeclaration
                          |
						  (NoFieldDeclarations) /* epsilon */ ;
							   
FieldDeclaration ::= (FieldDecl) FieldDeclSyntaxCheck SEMICOLON ;

FieldDeclSyntaxCheck ::= (FieldDeclSuccess) AccessModifier Type MultipleFieldDecl
                         |
						 (FieldDeclError) error:e
						 {: parser.report_error("Syntax Error on line " + eleft + "; error in field declaration", null); parser.syntaxErrorFound = true; :} ;
						 
AccessModifier ::= (PrivateAccess) PRIVATE
                   |
				   (ProtectedAccess) PROTECTED
				   |
				   (PublicAccess) PUBLIC
                   |
                   (ErrorAccess) error:e
				   {: parser.report_error("Syntax Error on line " + eleft + "; error in access modifier", null); parser.syntaxErrorFound = true; :} ;
					   
MultipleFieldDecl ::= (MultipleFieldDeclaration) MultipleFieldDecl COMMA SingleFieldDecl
                      |
					  (SingleFieldDeclaration) SingleFieldDecl ;
					
SingleFieldDecl ::= (SingleFieldDecl) SingleFieldDeclSyntaxCheck ;

SingleFieldDeclSyntaxCheck ::= (SingleFieldDeclSuccess) FieldName ArrayOption
                               |
							   (SingleFieldDeclError) error:e
							   {: parser.report_error("Syntax Error on line " + eleft + "; error in field declaration", null); parser.syntaxErrorFound = true; :} ;
							 
FieldName ::= (FieldName) IDENT:fieldName ;

ClassMethodDeclarationsOption ::= (ClassMethodDeclarationsStructure) LEFT_BRACE ClassMethodDeclarationsList RIGHT_BRACE
                                  |
								  (NoClassMethodDeclarationsStructure) /* epsilon */ ;
								  
AbstractClassDecl ::= (AbstractClassDecl) ABSTRACT CLASS AbstractClassDeclSyntaxCheck RIGHT_BRACE ;

AbstractClassDeclSyntaxCheck ::= (AbstractClassDeclSuccess) AbstractClassName ExtendsOption LEFT_BRACE FieldDeclarationsList AbstractClassMethodDeclarationsOption
                                 |
						         (AbstractClassDeclError) error:e
								 {: parser.report_error("Syntax Error on line " + eleft + "; error in abstract class declaration", null); parser.syntaxErrorFound = true; :} ;
								 
AbstractClassName ::= (AbstractClassName) IDENT:abstractClassName ;

AbstractClassMethodDeclarationsOption ::= (AbstractClassMethodDeclarationsStructure) LEFT_BRACE AbstractClassMethodDeclarationsList RIGHT_BRACE
                                          |
								          (NoAbstractClassMethodDeclarationsStructure) /* epsilon */ ;
								  
ClassMethodDeclarationsList ::= (ClassMethodDeclarations) ClassMethodDeclarationsList ClassMethodDecl
                                |
								(NoClassMethodDeclarations) /* epsilon */ ;
								
AbstractClassMethodDeclarationsList ::= (AbstractClassMethodDeclarations) AbstractClassMethodDeclarationsList ClassMethodDecl
                                        |
										(AbstractClassAbstractMethodDeclarations) AbstractClassMethodDeclarationsList AbstractMethodDecl
										|
										(NoAbstractClassMethodDeclarations) /* epsilon */ ;
 				
GlobalMethodDeclarationsList ::= (GlobalMethodDeclarations) GlobalMethodDeclarationsList MethodDecl
                                 |
								 (NoGlobalMethodDeclarations) /* epsilon */ ;

ClassMethodDecl ::= (ClassMethodDecl) AccessModifier ReturnType ClassMethodSyntaxCheck RIGHT_BRACE ;

AbstractMethodDecl ::= (AbstractMethodDecl) AccessModifier ABSTRACT ReturnType AbstractMethodDeclSyntaxCheck SEMICOLON ;
								 
MethodDecl ::= (MethodDecl) ReturnType MethodDeclSyntaxCheck RIGHT_BRACE ;

ReturnType ::= (MethodTypeReturn) Type
               |
			   (MethodVoidReturn) VOID ;
			   
MethodDeclSyntaxCheck ::= (MethodDeclSuccess) MethodDeclStructure 
                          |
						  (MethodDeclError) error:e
						  {: parser.report_error("Syntax Error on line " + eleft + "; error in method declaration", null); parser.syntaxErrorFound = true; :} ;
						  
ClassMethodSyntaxCheck ::= (ClassMethodDeclSuccess) MethodDeclStructure
                           |
						   (ClassMethodDeclError) error:e
						   {: parser.report_error("Syntax Error on line " + eleft + "; error in class method declaration", null); parser.syntaxErrorFound = true; :} ;
						   
AbstractMethodDeclSyntaxCheck ::= (AbstractMethodDeclSuccess) AbstractMethodName LEFT_PARENTHESIS FormParsOption RIGHT_PARENTHESIS 
                                  |
								  (AbstractMethodDeclError) error:e
								  {: parser.report_error("Syntax Error on line " + eleft + "; error in abstract method declaration", null); parser.syntaxErrorFound = true; :} ;
						   
MethodDeclStructure ::= (MethodDeclStructure) MethodName LEFT_PARENTHESIS FormParsOption RIGHT_PARENTHESIS LocalVarDeclarationsList LEFT_BRACE StatementList ;

MethodName ::= (MethodName) IDENT:methodName ;

AbstractMethodName ::= (AbstractMethodName) IDENT:abstractMethodName ;

FormParsOption ::= (FormalParameters) FormPars
                   |
				   (NoFormalParameters) /* epsilon */ ;

LocalVarDeclarationsList ::= (LocalVarDeclarations) LocalVarDeclarationsList LocalVarDecl
                             |
							 (NoLocalVarDeclarations) /* epsilon */ ;

LocalVarDecl ::= (LocalVarDecl) LocalVarDeclSyntaxCheck SEMICOLON ;

LocalVarDeclSyntaxCheck ::= (LocalVarDeclSuccess) Type MultipleLocalVarDecl
                            |
							(LocalVarDeclError) error:e
							{: parser.report_error("Syntax Error on line " + eleft + "; error in local variable declaration", null); parser.syntaxErrorFound = true; :} ;
					   
MultipleLocalVarDecl ::= (MultipleLocalVarDeclaration) MultipleLocalVarDecl COMMA SingleLocalVarDecl
                         |
						 (SingleLocalVarDeclaration) SingleLocalVarDecl ;
					
SingleLocalVarDecl ::= (SingleLocalVarDecl) SingleLocalVarDeclSyntaxCheck ;

SingleLocalVarDeclSyntaxCheck ::= (SingleLocalVarDeclSuccess) LocalVarName ArrayOption
                                  |
								  (SingleLocalVarDeclError) error:e
								  {: parser.report_error("Syntax Error on line " + eleft + "; error in local variable declaration", null); parser.syntaxErrorFound = true; :} ;
							 
LocalVarName ::= (LocalVarName) IDENT:localVarName ;

FormPars ::= (MultipleFormalParameterss) FormPars COMMA SingleFormPar
             |
			 (SingleFormalParameter) SingleFormPar ;
			 
SingleFormPar ::= (FormParSuccess) Type FormParName ArrayOption
                  |
				  (FormParError) error:e
				  {: parser.report_error("Syntax Error on line " + eleft + "; error in formal parameter declaration", null); parser.syntaxErrorFound = true; :} ;
				  
FormParName ::= (FormParName) IDENT:formParName ; 
							 
Type ::= (Type) IDENT:typeName ;

StatementList ::= (Statements) StatementList Statement
                  |
				  (NoStatements) /* epsilon */ ;
				  
Statement ::= (MatchedStmt) MatchedStatement
              |
			  (UnmatchedStmt) UnmatchedStatement ;
			  
MatchedStatement ::= (MatchedDesignatorStatement) MatchedDesignatorStatementSyntaxCheck
                     |
					 (MatchedIfStatement) MatchedIfSyntaxCheck
					 |
					 (MatchedForStatement) MatchedForSyntaxCheck
					 |
					 (MatchedForEachStatement) MatchedForEachSyntaxCheck
					 |
					 (BreakStatement) BreakSyntaxCheck
					 |
					 (ContinueStatement) ContinueSyntaxCheck
                     |
					 (ReturnStatement) ReturnSyntaxCheck
					 |
					 (ReadStatement) ReadSyntaxCheck
					 |
					 (PrintStatement) PrintSyntaxCheck
					 |
					 (MultipleStatements) LEFT_BRACE StatementList RIGHT_BRACE ;
					 
UnmatchedStatement ::= (UnmatchedIfStatement) UnmatchedIfSyntaxCheck
                       |
					   (UnmatchedElseStatement) UnmatchedElseSyntaxCheck
					   |
					   (UnmatchedForStatement) UnmatchedForSyntaxCheck
					   |
					   (UnmatchedForEachStatement) UnmatchedForEachSyntaxCheck ;

MatchedDesignatorStatementSyntaxCheck ::= (MatchedDesignatorStatementSuccess) DesignatorStatement SEMICOLON ;
					   
MatchedIfSyntaxCheck ::= (MatchedIfStatementSuccess) If LeftParenthesisExprStart ConditionSyntaxCheck RIGHT_PARENTHESIS MatchedStatement Else MatchedStatement
                         |
						 (MatchedIfStatementError) IfError Else MatchedStatement
						 |
						 (MatchedElseStatementError) If LeftParenthesisExprStart ConditionSyntaxCheck RIGHT_PARENTHESIS MatchedStatement Else error:e
						 {: parser.report_error("Syntax Error on line " + eleft + "; error in else statement", null); parser.syntaxErrorFound = true; :} ;
						 
MatchedForSyntaxCheck ::= (MatchedForStatementSuccess) For LEFT_PARENTHESIS FirstForDesignatorOption SEMICOLON ForConditionOption SEMICOLON SecondForDesignatorOption RIGHT_PARENTHESIS MatchedStatement
                          |
						  (MatchedForStatementError) ForError MatchedStatement ;
						  
MatchedForEachSyntaxCheck ::= (MatchedForEachStatementSuccess) Foreach LEFT_PARENTHESIS IteratorName COLON ForeachArray RIGHT_PARENTHESIS MatchedStatement
                              |
							  (MatchedForEachStatementError) ForEachError MatchedStatement ;
						 
BreakSyntaxCheck ::= (BreakStatementSuccess) BREAK SEMICOLON 
                     |
					 (BreakStatementError) BREAK error:e
					 {: parser.report_error("Syntax Error on line " + eleft + "; error in break statement", null); parser.syntaxErrorFound = true; :} ;
					 
ContinueSyntaxCheck ::= (ContinueStatementSuccess) CONTINUE SEMICOLON
                        |
                        (ContinueStatementError) CONTINUE error:e	
                        {: parser.report_error("Syntax Error on line " + eleft + "; error in continue statement", null); parser.syntaxErrorFound = true; :} ;			

ReturnSyntaxCheck ::= (ReturnStatementSuccess) Return ReturnExprOption SEMICOLON
                      |
                      (ReturnStatementError) Return error:e	
                      {: parser.report_error("Syntax Error on line " + eleft + "; error in return statement", null); parser.syntaxErrorFound = true; :} ;
					  
ReadSyntaxCheck ::= (ReadStatementSuccess) READ LEFT_PARENTHESIS Designator RIGHT_PARENTHESIS SEMICOLON
                    |
					(ReadStatementError) READ error:e
					{: parser.report_error("Syntax Error on line " + eleft + "; error in read statement", null); parser.syntaxErrorFound = true; :} ;
					
PrintSyntaxCheck ::= (PrintStatementSuccess) PRINT LeftParenthesisExprStart ExprSyntaxCheck PrintOption RIGHT_PARENTHESIS SEMICOLON
                     |
					 (PrintStatementError) PRINT error:e
					 {: parser.report_error("Syntax Error on line " + eleft + "; error in print statement", null); parser.syntaxErrorFound = true; :} ;
								  
UnmatchedIfSyntaxCheck ::= (UnmatcheedIfStatementSuccess) If LeftParenthesisExprStart ConditionSyntaxCheck RIGHT_PARENTHESIS Statement
                           |
						   (UnmatchedIfStatementError) IfError ;
						   
UnmatchedElseSyntaxCheck ::= (UnmatchedElseStatementSuccess) If LeftParenthesisExprStart ConditionSyntaxCheck RIGHT_PARENTHESIS MatchedStatement Else UnmatchedStatement
                             |
							 (UnmatchedElseStatementIfError) IfError Else UnmatchedStatement ;
						   
IfError ::= (IfError) If error:e
            {: parser.report_error("Syntax Error on line " + eleft + "; error in if statement", null); parser.syntaxErrorFound = true; :} ;

UnmatchedForSyntaxCheck ::= (UnmatchedForStatementSuccess) For LEFT_PARENTHESIS FirstForDesignatorOption SEMICOLON ForConditionOption SEMICOLON SecondForDesignatorOption RIGHT_PARENTHESIS UnmatchedStatement
                            |
							(UnmatchedForStatementError) ForError UnmatchedStatement ;	

ForError ::= (ForError) For error:e
             {: parser.report_error("Syntax Error on line " + eleft + "; error in for statement", null); parser.syntaxErrorFound = true; :} ;		

UnmatchedForEachSyntaxCheck ::= (UnmatchedForEachStatementSuccess) Foreach LEFT_PARENTHESIS IteratorName COLON ForeachArray RIGHT_PARENTHESIS UnmatchedStatement
                                |
								(UnmatchedForEachStatementError) ForEachError UnmatchedStatement ;
								
ForEachError ::= (ForEachError) Foreach error:e
                 {: parser.report_error("Syntax Error on line " + eleft + "; error in foreach statement", null); parser.syntaxErrorFound = true; :} ;
				 
DesignatorStatement ::= (AssignStatement) AssignStatementSyntaxCheck
                        |
						(MethodCallStatement) MethodCallName LEFT_PARENTHESIS ActParsOption RIGHT_PARENTHESIS
						|
						(IncrementStatement) Destination INC
						|
						(DecrementStatement) Destination DEC ;
						
AssignStatementSyntaxCheck ::= (AssignStatementSuccess) Destination Assignop Source
                               |
							   (AssignStatementError) error:e
							   {: parser.report_error("Syntax Error on line " + eleft + "; error in designator statement", null); parser.syntaxErrorFound = true; :} ;
							   
If ::= (If) IF ;

LeftParenthesisExprStart ::= (LeftParenthesisExprStart) LEFT_PARENTHESIS ;

Else ::= (Else) ELSE ;

For ::= (For) FOR ;

Foreach ::= (Foreach) FOREACH ;

Return ::= (Return) RETURN ;

ActParsOption ::= (ActualParameters) ActPars
                  |
				  (NoActualParameters) /* epsilon */ ;
				  
ActPars ::= (MultipleActualParameterss) ActPars COMMA SingleActPar
            |
			(SingleActualParameter) SingleActPar ;
			
SingleActPar ::= (SingleActPar) ExprSyntaxCheck ;

FirstForDesignatorOption ::= (FirstForDesignatorStatement) DesignatorStatement
                             |
							 (NoFirstForDesignatorStatement) /* epsilon */ ;
							 
ForConditionOption ::= (ForCondition) ConditionSyntaxCheck
                       |
					   (NoForCondition) /* epsilon */ ;
					   
SecondForDesignatorOption ::= (SecondForDesignatorStatement) DesignatorStatement
                              |
							  (NoSecondForDesignatorStatement) /* epsilon */ ;

ConditionSyntaxCheck ::= (ConditionSuccess) Condition
                         |
						 (ConditionError) error:e
						 {: parser.report_error("Syntax Error on line " + eleft + "; error in logical condition expresion", null); parser.syntaxErrorFound = true; :} ;
						 
IteratorName ::= (IteratorName) IDENT:iteratorName ;

ForeachArray ::= (ForeachArray) Designator ;

ReturnExprOption ::= (ReturnExpr) ExprSyntaxCheck
                     |
					 (NoReturnExpr) /* epsilon */ ;
					 
PrintOption ::= (PrintArg) COMMA NUMBER
                |
                (NoPrintArg) /* epsilon */ ;
				
MethodCallName ::= (MethodCallName) Designator ;

Destination ::= (Destination) Designator ;

Source ::= (Source) ExprSyntaxCheck ;

Assignop ::= (Assign) ASSIGN
             |
			 (AssignAddop) AddopRight
			 |
			 (AssignMulop) MulopRight ;
			 
Condition ::= (MultipleTermCondition) Condition OR CondTerm
              |
              (SingleTermCondition) CondTerm ;
			  
CondTerm ::= (MultipleFactTerm) CondTerm AND CondFact
             |
             (SingleFactTerm) CondFact ;
			 
CondFact ::= (MultipleExprFact) FirstExpr Relop SecondExpr
             |
             (SingleExprFact) SingleExpr ;
			 
FirstExpr ::= (FirstExpr) ExprSyntaxCheck;

SecondExpr ::= (SecondExpr) ExprSyntaxCheck;

SingleExpr ::= (SingleExpr) ExprSyntaxCheck;

ExprSyntaxCheck ::= (ExprSuccess) Expr;
					
Expr ::= (ExprWithAssign) AssignExpr
		 |
		 (ExprWithoutAssign) NoAssignExpr ;

AssignExpr ::= (AssignExprAddopAssign) Destination AddopRight AssignExpr
               |
			   (AssignExprMulopAssign) Destination MulopRight AssignExpr
			   |
               (AssignExprAddopNoAssign) Destination AddopRight NoAssignExpr
               |
               (AssignExprMulopNoAssign) Destination MulopRight NoAssignExpr ;			   

NoAssignExpr ::= (MultipleTermExpr) NoAssignExpr AddopLeft Term
                 |
                 (SingleTermExpr) Term
                 |
                 (MinusSingleTermExpr) MINUS Term
                 |
                 (NoAssignExprError) Destination Assignop error:e
            	 {: parser.report_error("Syntax Error on line " + eleft + "; error in expresion: cant have combined assign operator after non-combined add/mul operator", null); parser.syntaxErrorFound = true; :} ;
				 
Term ::= (MultipleFactorTerm) Term MulopLeft Factor
         |
         (SingleFactorTerm) Factor ;
		 
Factor ::= (FactorDesignator) FactorDesignator
           |
           (MethodDesignator) Designator LEFT_PARENTHESIS ActParsOption RIGHT_PARENTHESIS
           |
           (ConFactor) ConstFactor:constValue
           |
           (NewFactor) NEW Type
           |
           (NewArrayFactor) NEW Type LeftBracketExprStart ExprSyntaxCheck RIGHT_BRACKET
           |
           (CompositeFactor) LeftParenthesisExprStart ExprSyntaxCheck RIGHT_PARENTHESIS ;
		   
FactorDesignator ::= (FactorDesignator) Designator ;
		   
LeftBracketExprStart ::= (LeftBracketExprStart) LEFT_BRACKET ;

ConstFactor ::= (NumFactor) NUMBER:numberValue
                |
                (CharFactor) CHAR:charValue
                |
                (BoolFactor) BOOL:boolValue ;
				
Designator ::= (SimpleDesignator) IDENT:designName
               |
               (ClassDesignator) Designator PERIOD IDENT:fieldName
               |
               (ArrayDesignator) Designator LeftBracketExprStart ExprSyntaxCheck RIGHT_BRACKET ;
			   
Relop ::= (Equals) EQUALS:operationString
          |
          (NotEquals) NOT_EQUALS:operationString
          |
          (GreaterThan) GREATER_THAN:operationString
          |
          (GreaterThanEquals) GREATER_THAN_EQUALS:operationString
          |
          (LessThan) LESS_THAN:operationString
          |
          (LessThanEquals) LESS_THAN_EQUALS:operationString ;
		  
AddopLeft ::= (Plus) PLUS:operationString
              |
              (Minus) MINUS:operationString ;
			  
AddopRight ::= (PlusAssign) PLUSASSIGN:operationString
               |
               (MinusAssign) MINUSASSIGN:operationString ;
			   
MulopLeft ::= (Mul) MUL:operationString
              |
              (Div) DIV:operationString
              |
              (Mod) MOD:operationString ;
			  
MulopRight ::= (MulAssign) MULASSIGN:operationString
               |
               (DivAssign) DIVASSIGN:operationString
               |
               (ModAssign) MODASSIGN:operationString ;