package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
	
	Boolean syntaxErrorFound = false;   
   
    // redefined error methods
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        //report_error("Syntax Error", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal Error, parsing interrupted", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info != null) {
    		log.info (info.getClass());
    		log.info (info);
		}
    	if (info instanceof Symbol)
            msg.append (" on line ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}

scan with {:
	
	Symbol s = this.getScanner().next_token();
	/*if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString()); */
	return s;
	
:}

terminal PROGRAM, BREAK, CLASS, ABSTRACT, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXTENDS, CONTINUE;
terminal String IDENT;
terminal Integer NUMBER;
terminal Character CHAR;
terminal Boolean BOOL;
terminal String PLUS, MINUS, MUL, DIV, MOD;
terminal String EQUALS, NOT_EQUALS, GREATER_THAN, GREATER_THAN_EQUALS, LESS_THAN, LESS_THAN_EQUALS;
terminal AND, OR, ASSIGN, INC, DEC;
terminal SEMICOLON, COMMA, PERIOD;
terminal LEFT_BRACE, RIGHT_BRACE, LEFT_BRACKET, RIGHT_BRACKET, LEFT_PARENTHESIS, RIGHT_PARENTHESIS;

non terminal Program, DeclarationsList, Decl, MethodDeclarationsList, MethodDecl, AbstractMethodDecl, AbstractMethodDeclSyntaxCheck;
non terminal ConstDecl, MultipleConstDecl, SingleConstDecl, ConstValue, ConstSyntaxCheck, SingleConstDeclSyntaxCheck;
non terminal VarDecl, MultipleVarDecl, SingleVarDecl, ArrayOption, VarDeclSyntaxCheck, SingleVarDeclSyntaxCheck;
non terminal ClassDecl, ClassName, ExtendsOption, ClassVarDeclList, ClassVarDecl, ClassVarDeclSyntaxCheck, MultipleClassVarDecl, SingleClassVarDecl, SingleClassVarDeclSyntaxCheck, ClassMethodsOption, ExtendsSyntaxCheck;
non terminal AbstractClassDecl, Abstract, AbstractClassMethodsOption, AbstractClassMethodDeclarations;
non terminal ReturnType, FormParsOption, FormPars, SingleFormPar, MethodVarDeclList, StatementList;
non terminal Type;
non terminal Statement, MatchedStatement, UnmatchedStatement, MatchedDesignatorStatement;
non terminal ConditionSyntaxCheck, FirstForDesignatorOption, ForConditionOption, SecondForDesignatorOption, ReturnExprOption;
non terminal DesignatorStatement;
non terminal Condition, CondTerm, CondFact;
non terminal Designator, Expr, PrintOption, Destination, Source, ActParamsOption, Assignop, ActPars, ActPar, Relop, Addop, Term, Mulop, Factor, MethodDesign, ConstFactor;

Program ::= (Program) PROGRAM IDENT:programName DeclarationsList LEFT_BRACE MethodDeclarationsList RIGHT_BRACE ;

DeclarationsList ::= (GlobalDeclarations) DeclarationsList Decl
                     |
					 (NoGlobalDeclarations) /* epsilon */ ;
					 
MethodDeclarationsList ::= (MethodsDeclarations) MethodDeclarationsList MethodDecl
                           |
					       (NoMethodsDeclarations) /* epsilon */ ;

Decl ::= (ConstDeclaration) ConstDecl
         |
		 (VariableDeclaration) VarDecl
		 |
		 (AbstractClassDeclaration) AbstractClassDecl
		 |
		 (ClassDeclaration) ClassDecl;
		 
ConstDecl ::= (ConstDecl) CONST ConstSyntaxCheck SEMICOLON;

ConstSyntaxCheck ::= (ConstDeclSuccess) Type:constType MultipleConstDecl
                     |
					 (ConstDeclError) error:e 
					 {: parser.report_error("Syntax Error on line " + eleft + "; error in constant declaration", null); parser.syntaxErrorFound = true; :}  ;

MultipleConstDecl ::= (MultipleConstDeclaration) MultipleConstDecl COMMA SingleConstDecl
                      |
					  (SingleConstDeclaration) SingleConstDecl ;
					  
SingleConstDecl ::= (SingleConstDecl) SingleConstDeclSyntaxCheck;
					  
SingleConstDeclSyntaxCheck ::= (SingleConstDeclSuccess) IDENT:constName ASSIGN ConstValue:constValue
                               |
							   (SingleConstDeclError) error:e 
							   {: parser.report_error("Syntax Error on line " + eleft + "; error in constant declaration", null); parser.syntaxErrorFound = true; :}  ;

ConstValue ::= (NumConst) NUMBER:numberValue
               |
               (CharConst) CHAR:charValue
               |
               (BoolConst) BOOL:boolValue ;

VarDecl ::= (VarDecl) VarDeclSyntaxCheck SEMICOLON ;

VarDeclSyntaxCheck ::= (VarDeclSuccess) Type:varType MultipleVarDecl
                       |
					   (VarDeclError) error:e 
					   {: parser.report_error("Syntax Error on line " + eleft + "; error in variable declaration", null); parser.syntaxErrorFound = true; :}  ;

MultipleVarDecl ::= (MultipleVarDeclaration) MultipleVarDecl COMMA SingleVarDecl
				    |
					(SingleVarDeclaration) SingleVarDecl ;
					
SingleVarDecl ::= (SingleVarDecl) SingleVarDeclSyntaxCheck ;
					
SingleVarDeclSyntaxCheck ::= (SingleVarDeclSuccess) IDENT:varName ArrayOption 
							 |
							 (SingleVarDeclError) error:e
							 {: parser.report_error("Syntax Error on line " + eleft + "; error in variable declaration", null); parser.syntaxErrorFound = true; :}  ;

ArrayOption ::= (ArrayVariable) LEFT_BRACKET RIGHT_BRACKET
                |
				(NoArrayVariable) /* epsilon */ ;
				
ClassDecl ::= (ClassDecl) CLASS ClassName ExtendsOption LEFT_BRACE ClassVarDeclList ClassMethodsOption RIGHT_BRACE ;

AbstractClassDecl ::= (AbstractClassDecl) Abstract CLASS ClassName ExtendsOption LEFT_BRACE ClassVarDeclList AbstractClassMethodsOption RIGHT_BRACE ;

Abstract ::= (Abstract) ABSTRACT;

ClassName ::= (ClassName) IDENT:className ;

ExtendsOption ::= (ClassInheritance) ExtendsSyntaxCheck
                  |
				  (NoClassInheritance) /* epsilon */;
				
ExtendsSyntaxCheck ::= (ClassInheritanceSuccess) EXTENDS Type:superClassType
                       |
					   (ClassInheritanceError) error:e
						{: parser.report_error("Syntax Error on line " + eleft + "; error in class inheritance", null); parser.syntaxErrorFound = true; :}  ;
						
ClassVarDeclList ::= (ClassVarDeclarations) ClassVarDeclList ClassVarDecl
                     |
                     (NoClassVarDeclarations) /* epsilon */ ;
					 
ClassVarDecl ::= (ClassVarDecl) ClassVarDeclSyntaxCheck SEMICOLON ;

ClassVarDeclSyntaxCheck ::= (ClassVarDeclSuccess) Type:classVarType MultipleClassVarDecl
                            |
					        (ClassVarDeclError) error:e 
					        {: parser.report_error("Syntax Error on line " + eleft + "; error in class field declaration", null); parser.syntaxErrorFound = true; :}  ;

MultipleClassVarDecl ::= (MultipleClassVarDeclaration) MultipleClassVarDecl COMMA SingleClassVarDecl
				         |
					     (SingleClassVarDeclDeclaration) SingleClassVarDecl ;

SingleClassVarDecl ::= (SingleClassVarDecl) SingleClassVarDeclSyntaxCheck ;

SingleClassVarDeclSyntaxCheck ::= (SingleClassVarDeclSuccess) IDENT:fieldName ArrayOption 
							      |
							      (SingleClassVarDeclError) error:e
							      {: parser.report_error("Syntax Error on line " + eleft + "; error in class field declaration", null); parser.syntaxErrorFound = true; :}  ;
						 
ClassMethodsOption ::= (ClassMethods) LEFT_BRACE MethodDeclarationsList RIGHT_BRACE
                       |
					   (NoClassMethods) /* epsilon */ ;
					   
AbstractClassMethodsOption ::= (AbstractClassMethods) LEFT_BRACE AbstractClassMethodDeclarations RIGHT_BRACE
							   |
							   (NoAbstractClassMethods) /* epsilon */ ;
							   
AbstractClassMethodDeclarations ::= (AbstractClassMethodsDeclarations) AbstractClassMethodDeclarations MethodDecl
                                    |
									(AbstractClassAbstractMethodsDeclarations) AbstractClassMethodDeclarations AbstractMethodDecl
									|
									(NoAbstractClassMethodsDeclarations) /* epsilon */ ;
									
AbstractMethodDecl ::= (AbstractMethodDecl) AbstractMethodDeclSyntaxCheck SEMICOLON ;

AbstractMethodDeclSyntaxCheck ::= (AbstractMethodDeclSuccess) Abstract ReturnType IDENT:methodName LEFT_PARENTHESIS FormParsOption RIGHT_PARENTHESIS
                                  |
								  (AbstractMethodDeclError) error:e
								  {: parser.report_error("Syntax Error on line " + eleft + "; error in abstract method declaration", null); parser.syntaxErrorFound = true; :} ;

MethodDecl ::= (MethodDecl) ReturnType IDENT:methodName LEFT_PARENTHESIS FormParsOption RIGHT_PARENTHESIS MethodVarDeclList LEFT_BRACE StatementList RIGHT_BRACE ;

MethodVarDeclList ::= (MethodVarDeclarations) MethodVarDeclList VarDecl
                      |
                      (NoMethodVarDeclarations) /* epsilon */ ;

ReturnType ::= (MethodVoidReturn) VOID
               |
			   (MethodTypeReturn) Type:returnType ;
			   
FormParsOption ::= (FormalParameters) FormPars
                   |
				   (NoFormalParameters) /* epsilon */ ;
				   
FormPars ::= (MultipleFormalParameters)FormPars COMMA SingleFormPar
             |
			 (SingleFormalParameter) SingleFormPar ;
			 
SingleFormPar ::= (SingleFormParSuccess) Type IDENT:formParName ArrayOption
				  |
				  (SingleFormParError) error:e
				  {: parser.report_error("Syntax Error on line " + eleft + "; error in formal parameter declaration", null); parser.syntaxErrorFound = true; :} ;

Type ::= (Type) IDENT:typeName ;

StatementList ::= (Statements) StatementList Statement
                  |
                  (NoStatements) /* epsilon */ ;
				  
Statement ::= (MatchedStmt) MatchedStatement
              |
              (UnmatchedStmt) UnmatchedStatement ;
			  
MatchedStatement ::= (MatchedDesignatorStmt) MatchedDesignatorStatement
                     |
					 (MatchedIfStatement) IF LEFT_PARENTHESIS ConditionSyntaxCheck RIGHT_PARENTHESIS MatchedStatement ELSE MatchedStatement
					 |
					 (MatchedForStatement) FOR LEFT_PARENTHESIS FirstForDesignatorOption SEMICOLON ForConditionOption SEMICOLON SecondForDesignatorOption RIGHT_PARENTHESIS MatchedStatement
					 |
					 (BreakStatement) BREAK SEMICOLON
					 |
					 (ContinueStatement) CONTINUE SEMICOLON
					 |
					 (ReturnStatement) RETURN ReturnExprOption SEMICOLON
					 |
					 (ReadStatement) READ LEFT_PARENTHESIS Designator RIGHT_PARENTHESIS SEMICOLON
					 |
					 (PrintStatement) PRINT LEFT_PARENTHESIS Expr PrintOption RIGHT_PARENTHESIS SEMICOLON
					 |
					 (MultipleStatements) LEFT_BRACE StatementList RIGHT_BRACE;
					 
UnmatchedStatement ::= (UnmatchedIfStatement) IF LEFT_PARENTHESIS ConditionSyntaxCheck RIGHT_PARENTHESIS Statement
                       |
                       (UnmatchedElseStatement) IF LEFT_PARENTHESIS ConditionSyntaxCheck RIGHT_PARENTHESIS MatchedStatement ELSE UnmatchedStatement
                       |
                       (UnmatchedForStatement) FOR LEFT_PARENTHESIS FirstForDesignatorOption SEMICOLON ForConditionOption SEMICOLON SecondForDesignatorOption RIGHT_PARENTHESIS UnmatchedStatement ;
					   
ConditionSyntaxCheck ::= (ConditionSuccess) Condition
                         |
                         (ConditionError) error:e
                         {: parser.report_error("4Syntax Error on line " + eleft + "; error in logical condition", null); parser.syntaxErrorFound = true; :} ; 
						 
FirstForDesignatorOption ::= (FirstForDesignatorStatement) DesignatorStatement
                             |
                             (NoFirstForDesignatorStatement) /* epsilon */ ;
							 
ForConditionOption ::= (ForCondition) ConditionSyntaxCheck
                       |
                       (NoForCondition) /* epsilon */ ; 
                             
SecondForDesignatorOption ::= (SecondForDesignatorStatement) DesignatorStatement
                              |
                              (NoSecondForDesignatorStatement) /* epsilon */  ;
							  
ReturnExprOption ::= (ReturnExpr) Expr
                     |
                     (NoReturnExpr) /* epsilon */ ;
					 
PrintOption ::= (PrintArg) COMMA NUMBER
                |
                (NoPrintArg) /* epsilon */ ;
				
MatchedDesignatorStatement ::= (MatchedDesignatorStatementSuccess) DesignatorStatement SEMICOLON
                               |
                               (MatchedDesignatorStatementError) error:e SEMICOLON
                               {: parser.report_error("4Syntax Error on line " + eleft + "; error in designator statement", null); parser.syntaxErrorFound = true; :}  ;
							   
DesignatorStatement ::= (AssignStatementSuccess) Destination Assignop Source
                        |
                        (MethodCallStatement) Destination LEFT_PARENTHESIS ActParamsOption RIGHT_PARENTHESIS
                        |
                        (IncrementStatement) Destination INC
                        |
                        (DecrementStatement) Destination DEC;
						
Destination ::= (Destination) Designator ;           

Source ::= (Source) Expr; 
            
ActParamsOption ::= (ActualParameters) ActPars
                    |
                    (NoActualParameters) /* epsilon */  ; 
					
ActPars ::= (MultipleActualParameters) ActPars COMMA ActPar
            |
            (SingleActualParameters) ActPar ;

ActPar ::= (ActPar) Expr ;

Condition ::= (MultipleTermCondition) Condition OR CondTerm
              |
              (SingleTermCondition) CondTerm ;
			  
CondTerm ::= (MultipleFactTerm) CondTerm AND CondFact
             |
             (SingleFactTerm) CondFact ;
			 
CondFact ::= (MultipleExprFact) Expr:firstExpr Relop Expr:secondExpr
             |
             (SingleExprFact) Expr ;
			 
Expr ::= (MultipleTermExpr) Expr Addop Term
         |
         (SingleTermExpr) Term
         |
         (MinusSingleTermExpr) MINUS Term ;
		 
Term ::= (MultipleFactorTerm) Term Mulop Factor
         |
         (SingleFactorTerm) Factor ;
		 
Factor ::= (DeclDesignator) Designator
           |
           (MethodDesignator) MethodDesign LEFT_PARENTHESIS ActParamsOption RIGHT_PARENTHESIS
           |
           (ConFactor) ConstFactor:constValue
           |
           (NewFactor) NEW Type
           |
           (NewArrayFactor) NEW Type LEFT_BRACKET Expr RIGHT_BRACKET
           |
           (CompositeFactor) LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS ;
		   
MethodDesign ::= (MethodDesign) Designator;

ConstFactor ::= (NumFactor) NUMBER:numberValue
                |
                (CharFactor) CHAR:charValue
                |
                (BoolFactor) BOOL:boolValue ;
				
Designator ::= (SimpleDesignator) IDENT:designName
               |
               (ClassOrEnumDesignator) Designator PERIOD IDENT:fieldName
               |
               (ArrayDesignator) Designator LEFT_BRACKET Expr RIGHT_BRACKET ;
			   
Assignop ::= (Assign) ASSIGN;

Relop ::= (Equals) EQUALS:operationString
          |
          (NotEquals) NOT_EQUALS:operationString
          |
          (GreaterThan) GREATER_THAN:operationString
          |
          (GreaterThanEquals) GREATER_THAN_EQUALS:operationString
          |
          (LessThan) LESS_THAN:operationString
          |
          (LessThanEquals) LESS_THAN_EQUALS:operationString ;
          
Addop ::= (Plus) PLUS:operationString
          |
          (Minus) MINUS:operationString ;
          
Mulop ::= (Mul) MUL:operationString
          |
          (Div) DIV:operationString
          |
          (Mod) MOD:operationString ;